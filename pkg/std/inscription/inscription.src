/////////////////////////////////////////////////////////////////////////////
//
//  inscription.src - Inscription skill
//
//  Modifications:
//	  19990415 ENS Reformatted
//	  20010321 Jaleem Added autolooping for scroll creation 
//	  20010411 Jaleem Fixed autoloop bug 
//	  20010505 Jaleem Commented out old set_priority()
/////////////////////////////////////////////////////////////////////////////
use uo;
use basic;
use cfgfile;
use os;

include "include/attributes";
include ":gumps:yesno";
include "include/bitwise";
include "include/client";
include "include/objtype";
include "include/skillpoints";
include "include/itemutil";
include "include/classes";
include "include/string";
include "include/random";
include "include/autoloop";
include "include/difficulty";


const SOUND_EFFECT_INSCRIPTION 	:= 0x50;
const SOUND_EFFECT_SPARKLE 	:= 0x1e8;
const EFFECT_SPARKLE 		:= 0x373a;
const POINT_MULTIPLIER		:= 15;

var config_file;


program DoInscription( character )

	var item;
	var spellbooks := { UOBJ_SPELLBOOK,
			      UOBJ_CODEX_DAMNORUM,
			      UOBJ_EARTH_BOOK,
			      UOBJ_TOME_OF_ENCHANTMENT };
  
	SendSysmessage( character , "What would you like to inscribe?" );
  
	item := Target( character , TGTOPT_CHECK_LOS );
   
	if( !item )
		return;
	endif

	if( !Accessible( character , item ) )
		SendSysmessage( character , "You can't reach that!" );
		return;
	endif
	
	if( !ReserveItem( item ) )
		return;
	endif
  
	config_file := ReadConfigFile( "inscription" );
	
	/*if( IsExceptionalItem( item ) )
		var enchantment := GetObjProperty( item , "EnchantedWith" );
		if( enchantment )
			RechargeEngravedItem( character , item , enchantment );
		else
			EnchantItem( character , item );
		endif

	else*/
	if( item.objtype == UOBJ_BLANK_SCROLL )
		Set_script_option( SCRIPTOPT_NO_RUNAWAY , 1 );
		WantToCreateScroll( character , item );
		
	elseif( (item.objtype >= 0xA101) and (item.objtype <= 0xA110) )
		InscribeNecroSpell( character , item );
	elseif( (item.objtype >= 0xB101) and (item.objtype <= 0xB110) )
		InscribeEarthSpell( character , item );
	elseif( (item.objtype >= 0x6167) and (item.objtype <= 0x6176) )
		InscribeHolySpell( character , item );	
	elseif( (item.objtype >= 0xC101) and (item.objtype <= 0xC120) )
		SendSysMessage( character , "You can't do that." );
		return;
		//InscribeRitualSpell( character , item );
		
	// blank runes are stackable and a diff objtype now
	elseif( item.objtype == 0x1f17 )
		CreateRunebook( character , item );

	elseif (item.objtype == UOBJ_RUNE)
		SendSysMessage( character , "You must target a blank rune." );
		
	elseif( item.objtype == UOBJ_SPELLBOOK )
		CheckIfEmptyNormal( character , item );

	elseif( item.objtype in spellbooks )
		
		SendSysMessage( character , "You can't do that." );
		return;
		//CheckIfEmpty( character , item );
		
	elseif( GetObjProperty( item , "Rechargeable" ) )
		RechargeItem( character , item );
		
	else
		SendSysMessage(character, "You can't inscribe that!");
	endif
	
endprogram


function ChangeName( item , suffix )

	var currdesc := Cstr(item.desc);
	var space := Find( item.desc , "[" , 1 );
	if( space )
		var first_part  := currdesc[1 , (space-1)];
		var second_part := currdesc[space , (len(currdesc) - space - 1)];
		SetName( item , first_part + suffix + " " + second_part );
		SetObjProperty( item , "BaseName" , first_part + suffix + " " + second_part );
	else
		SetName( item , currdesc + " " + suffix );
		SetObjProperty( item , "BaseName" , currdesc + " " + suffix );
	endif

endfunction


function ChooseEarthSpell( character , earthbook )

	var layout := {
			"page 0",
			"gumppic 0 0 2203",
			"text 40 10 28 0",
			"text 200 10 28 1"
			};

	var LSpellArray := { 0xB101 , 0xB102 , 0xB103 , 0xB104 , 0xB105 , 0xB106 , 0xB107 , 0xB108 };
	var GSpellArray := { 0xB109 , 0xB10A , 0xB10B , 0xB10C , 0xB10D , 0xB10E , 0xB10F , 0xB110 };
	var BookArray := {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	var LesserButtonLayout := {
				"button 30 40 2104 2103 1 0 101",
				"button 30 60 2104 2103 1 0 102",
				"button 30 80 2104 2103 1 0 103",
				"button 30 100 2104 2103 1 0 104",
				"button 30 120 2104 2103 1 0 105",
				"button 30 140 2104 2103 1 0 106",
				"button 30 160 2104 2103 1 0 107",
				"button 30 180 2104 2103 1 0 108"
				};


	var GreaterButtonLayout := {
				"button 190 40 2104 2103 1 0 109",
				"button 190 60 2104 2103 1 0 110",
				"button 190 80 2104 2103 1 0 111",
				"button 190 100 2104 2103 1 0 112",
				"button 190 120 2104 2103 1 0 113",
				"button 190 140 2104 2103 1 0 114",
				"button 190 160 2104 2103 1 0 115",
				"button 190 180 2104 2103 1 0 116"
				};


	var LesserTextLayout := {
				"text 50 35 0 ",
				"text 50 55 0 ",
				"text 50 75 0 ",
				"text 50 95 0 ",
				"text 50 115 0 ",
				"text 50 135 0 ",
				"text 50 155 0 ",
				"text 50 175 0 "
				};


	var GreaterTextLayout := {
				"text 210 35 0 ",
				"text 210 55 0 ",
				"text 210 75 0 ",
				"text 210 95 0 ",
				"text 210 115 0 ",
				"text 210 135 0 ",
				"text 210 155 0 ",
				"text 210 175 0 "
				};


	var data 		:= {
				"Circle 1 Scrolls",
				"Circle 2 Scrolls"
				};


	var LesserSpellData := {
				"Antidote",
				"Owl Sight",
				"Shifting Earth",
				"Summon Mammals",
				"Call Lightning",
				"Earth Blessing",
				"Earth Portal",
				"Nature's Touch"
				};
		
		
	var GreaterSpellData := {
				"Gust of Air",
				"Rising Fire",
				"Shapeshift",
				"Ice Strike",
				"Earth Spirit",
				"Flame Spirit",
				"Storm Spirit",
				"Water Spirit"
				};


	var i := 1;
	var q := 8;
	var LTotal := 0;
	var GTotal := 0;

	var LayoutLen := len(layout);
	var DataLen := len(data);

	var GreaterFlag := Cint(GetObjProperty( earthbook , "Greater" ));
	var LesserFlag := Cint(GetObjProperty( earthbook , "Lesser" ));

	while (i < 9)
		if (FlagCheck(LesserFlag, i)==1)
			LTotal := LTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserButtonLayout[LTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserTextLayout[LTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := LesserSpellData[i];
			BookArray[LTotal] := LSpellArray[i];
		endif
		if (FlagCheck(GreaterFlag, i)==1)
			GTotal := GTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterButtonLayout[GTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterTextLayout[GTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := GreaterSpellData[i];
			q := 8 + GTotal;
			BookArray[q] := GSpellArray[i];
		endif
		i := i + 1;
	 endwhile

	SendSysMessage( character , "Select the spell you want to scribe." );
   
	var res := SendDialogGump( character , layout , data );						 

	if (res[0] < 100)
		return 0;
	endif

	var selected := res[0] - 100;
	selected := BookArray[selected];

	return selected;

endfunction

function ChooseHolySpell( character , holybook )

	var layout := {
			"page 0",
			"gumppic 0 0 2203",
			"text 40 10 28 0",
			"text 200 10 28 1"
			};

	var LSpellArray := { 0x6167 , 0x6168 , 0x6169 , 0x616a , 0x616b , 0x616c , 0x616d , 0x616e };
	var GSpellArray := { 0x616f , 0x6170 , 0x6171 , 0x6172 , 0x6173 , 0x6174 , 0x6175 , 0x6176 };
	var BookArray := {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	var LesserButtonLayout := {
				"button 30 40 2104 2103 1 0 101",
				"button 30 60 2104 2103 1 0 102",
				"button 30 80 2104 2103 1 0 103",
				"button 30 100 2104 2103 1 0 104",
				"button 30 120 2104 2103 1 0 105",
				"button 30 140 2104 2103 1 0 106",
				"button 30 160 2104 2103 1 0 107",
				"button 30 180 2104 2103 1 0 108"
				};


	var GreaterButtonLayout := {
				"button 190 40 2104 2103 1 0 109",
				"button 190 60 2104 2103 1 0 110",
				"button 190 80 2104 2103 1 0 111",
				"button 190 100 2104 2103 1 0 112",
				"button 190 120 2104 2103 1 0 113",
				"button 190 140 2104 2103 1 0 114",
				"button 190 160 2104 2103 1 0 115",
				"button 190 180 2104 2103 1 0 116"
				};


	var LesserTextLayout := {
				"text 50 35 0 ",
				"text 50 55 0 ",
				"text 50 75 0 ",
				"text 50 95 0 ",
				"text 50 115 0 ",
				"text 50 135 0 ",
				"text 50 155 0 ",
				"text 50 175 0 "
				};


	var GreaterTextLayout := {
				"text 210 35 0 ",
				"text 210 55 0 ",
				"text 210 75 0 ",
				"text 210 95 0 ",
				"text 210 115 0 ",
				"text 210 135 0 ",
				"text 210 155 0 ",
				"text 210 175 0 "
				};


	var data 		:= {
				"Circle 1 Scrolls",
				"Circle 2 Scrolls"
				};


	var LesserSpellData := {
				"Grand Feast",
				"Turn Undead",
				"Light of Day",
				"Angelic Aura",
				"Holy Bolt",
				"Seraphim's Will",
				"Angelic Gate",
				"Remove Curse"
				};
		
		
	var GreaterSpellData := {
				"Wrath of God",
				"Divine Fury",
				"Astral Storm",
				"Enlightenment",
				"Revive",
				"Sanctuary",
				"Summon Guardian",
				"Apocalypse"
				};


	var i := 1;
	var q := 8;
	var LTotal := 0;
	var GTotal := 0;

	var LayoutLen := len(layout);
	var DataLen := len(data);

	var GreaterFlag := Cint(GetObjProperty( holybook , "Greater" ));
	var LesserFlag := Cint(GetObjProperty( holybook , "Lesser" ));

	while (i < 9)
		if (FlagCheck(LesserFlag, i)==1)
			LTotal := LTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserButtonLayout[LTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserTextLayout[LTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := LesserSpellData[i];
			BookArray[LTotal] := LSpellArray[i];
		endif
		if (FlagCheck(GreaterFlag, i)==1)
			GTotal := GTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterButtonLayout[GTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterTextLayout[GTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := GreaterSpellData[i];
			q := 8 + GTotal;
			BookArray[q] := GSpellArray[i];
		endif
		i := i + 1;
	 endwhile

	SendSysMessage( character , "Select the spell you want to scribe." );
   
	var res := SendDialogGump( character , layout , data );						 

	if (res[0] < 100)
		return 0;
	endif

	var selected := res[0] - 100;
	selected := BookArray[selected];

	return selected;

endfunction



function ChooseNecroSpell( character , codex )

	var layout := {
			"page 0",
			"gumppic 30 30 2200",
			"text 70 40 28 0",
			"text 230 40 28 1"
			};

	var LSpellArray 	:= { 0xA101 , 0xA102 , 0xA103 , 0xA104 , 0xA105 , 0xA106 , 0xA107 , 0xA108 };
	var GSpellArray 	:= { 0xA109 , 0xA10A , 0xA10B , 0xA10C , 0xA10D , 0xA10E , 0xA10F , 0xA110 };
	var BookArray 	:= {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	var LesserButtonLayout := {
					"button 60 70 2104 2103 1 0 101",
					"button 60 90 2104 2103 1 0 102",
					"button 60 110 2104 2103 1 0 103",
					"button 60 130 2104 2103 1 0 104",
					"button 60 150 2104 2103 1 0 105",
					"button 60 170 2104 2103 1 0 106",
					"button 60 190 2104 2103 1 0 107",
					"button 60 210 2104 2103 1 0 108"
					};


	var GreaterButtonLayout := {
					"button 220 70 2104 2103 1 0 109",
					"button 220 90 2104 2103 1 0 110",
					"button 220 110 2104 2103 1 0 111",
					"button 220 130 2104 2103 1 0 112",
					"button 220 150 2104 2103 1 0 113",
					"button 220 170 2104 2103 1 0 114",
					"button 220 190 2104 2103 1 0 115",
					"button 220 210 2104 2103 1 0 116"
					};


	var LesserTextLayout := {
					"text 80 65 0 ",
					"text 80 85 0 ",
					"text 80 105 0 ",
					"text 80 125 0 ",
					"text 80 145 0 ",
					"text 80 165 0 ",
					"text 80 185 0 ",
					"text 80 205 0 "
					};


	var GreaterTextLayout := {
					"text 240 65 0 ",
					"text 240 85 0 ",
					"text 240 105 0 ",
					"text 240 125 0 ",
					"text 240 145 0 ",
					"text 240 165 0 ",
					"text 240 185 0 ",
					"text 240 205 0 "
					};


	var data 		:= {
					"Lesser Scrolls",
					"Greater Scrolls"
					};


	var LesserSpellData := {
					"Control Undead",
					"Darkness",
					"Decaying Ray",
					"Spectre's Touch",
					"Abyssal Flame",
					"Animate Dead",
					"Sacrifice",
					"Wraith's Breath"
					};


	var GreaterSpellData := {
					"Sorcerer's Bane",
					"Summon Spirit",
					"Wraithform",
					"Wyvern Strike",
					"Kill",
					"Liche",
					"Plague",
					"Spellbind"
					};

	var i := 1;
	var q := 8;
	var LTotal := 0;
	var GTotal := 0;

	var LayoutLen := len( layout );
	var DataLen := len( data );

	var GreaterFlag := GetObjProperty( codex , "Greater" );
	var LesserFlag := GetObjProperty( codex , "Lesser" );

	GreaterFlag := CInt( GreaterFlag );
	LesserFlag := CInt( LesserFlag );

	while (i < 9)
		if( FlagCheck( LesserFlag , i ) == 1 )
			LTotal := LTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserButtonLayout[LTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := LesserTextLayout[LTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := LesserSpellData[i];
			BookArray[LTotal] := LSpellArray[i];
		endif
		
		if( FlagCheck( GreaterFlag , i ) == 1 )
			GTotal := GTotal + 1;
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterButtonLayout[GTotal];
			LayoutLen := LayoutLen + 1;
			layout[LayoutLen] := GreaterTextLayout[GTotal] + Cstr(1 + LTotal + GTotal);
			DataLen := DataLen + 1;
			data[DataLen] := GreaterSpellData[i];
			q := 8 + GTotal;
			BookArray[q] := GSpellArray[i];
		endif
		
		i := i + 1;
	endwhile

	SendSysMessage( character , "Select the spell you want to scribe." );
			
	var res := SendDialogGump( character , layout , data );						 

	if( res[0] < 100 )
		return 0;
	endif

	var selected := res[0] - 100;
	selected := BookArray[selected];

	return selected;

endfunction


function ChooseRitualSpell( character , tome )

	var layout	:= array( "page 0" , "gumppic 0 0 2201" );
	var data	:= array();

	var LeftButtonLayout := {
		"button 30 40  2104 2103 1 0 ",
		"button 30 60  2104 2103 1 0 ",
		"button 30 80  2104 2103 1 0 ",
		"button 30 100 2104 2103 1 0 ",
		"button 30 120 2104 2103 1 0 ",
		"button 30 140 2104 2103 1 0 ",
		"button 30 160 2104 2103 1 0 ",
		"button 30 180 2104 2103 1 0 "};

	var RightButtonLayout := {
		"button 190 40  2104 2103 1 0 ",
		"button 190 60  2104 2103 1 0 ",
		"button 190 80  2104 2103 1 0 ",
		"button 190 100 2104 2103 1 0 ",
		"button 190 120 2104 2103 1 0 ",
		"button 190 140 2104 2103 1 0 ",
		"button 190 160 2104 2103 1 0 ",
		"button 190 180 2104 2103 1 0 "};

	var LeftTextLayout := {
		"text 50 35  0 ",
		"text 50 55  0 ",
		"text 50 75  0 ",
		"text 50 95  0 ",
		"text 50 115 0 ",
		"text 50 135 0 ",
		"text 50 155 0 ",
		"text 50 175 0 "};

	var RightTextLayout := {
		"text 210 35  0 ",
		"text 210 55  0 ",
		"text 210 75  0 ",
		"text 210 95  0 ",
		"text 210 115 0 ",
		"text 210 135 0 ",
		"text 210 155 0 ",
		"text 210 175 0 "};

	var C1SpellArray := { 0xC101, 0xC102, 0xC103, 0xC104, 0xC105, 0xC106, 0xC107, 0xC108 };
	var C2SpellArray := { 0xC109, 0xC10A, 0xC10B, 0xC10C, 0xC10D, 0xC10E, 0xC10F, 0xC110 };
	var C3SpellArray := { 0xC111, 0xC112, 0xC113, 0xC114, 0xC115, 0xC116, 0xC117, 0xC118 };
	var C4SpellArray := { 0xC119, 0xC11A, 0xC11B, 0xC11C, 0xC11D, 0xC11E, 0xC11F, 0xC120 };
	var BookArray    := { };

	var C1SpellData := {
		"Channel Mana"	,
		"Consecration"	,
		"Free Movement"	,
		"Quick Healing"	,
		"Regeneration"	,
		"Resilience"	,
		"Restoration"	,
		"Venom Bane"	};

	var C2SpellData := {
		"Cursing"	,
		"Disenchantment",
		"Elemental Ward",
		"Mana Flux"	,
		"Planar Ward"	,
		"Sanctifying"	,
		"Skill Infusion",
		"Venom Mastery" };

	var C3SpellData := {
		"Bloodseeking"	,
		"Hardening"	,
		"Mana Dimissal"	,
		"Physical Ward" ,
		"Protective Aura",
		"Spell Bouncing",
		"Spell Warding"	,
		"Vital Infusion"};

	var C4SpellData := {
		"Advanced Theurgy",
		"Attunement"	,
		"Basic Theurgy"	,
		"Enhancement"	,
		"Immutability"	,
		"Perilous Theurgy",
		"Purification"	,
		"Racial Theurgy"};
   

	var pagecount	:= 0;
	var perCircle := 8;

	var	C1Flag := GetObjProperty( tome , "Circle1" ),
		C2Flag := GetObjProperty( tome , "Circle2" ),
		C3Flag := GetObjProperty( tome , "Circle3" ),
		C4Flag := GetObjProperty( tome , "Circle4" );
		
		
	var 	circles := {	{ C1Flag , C1SpellArray , C1SpellData , 
				  C2Flag , C2SpellArray , C2SpellData }	,
					
				{ C3Flag , C3SpellArray , C3SpellData ,
				  C4Flag , C4SpellArray , C4SpellData }	};
				
	
	foreach circle in circles
	
		var i		:= 1;
		
		var lefttotal	:= 0;
		var righttotal := 0;
		
		var leftflag	:= circle[1];
		var leftarray	:= circle[2];
		var leftdata	:= circle[3];
		
		var rightflag	:= circle[4];
		var rightarray := circle[5];
		var rightdata	:= circle[6];
			
		pagecount := pagecount + 1;
		layout.append( "page " + pagecount );
		if( pagecount != 1 )
			layout.append( "button 24 4 2235 2235 0 " + ( pagecount-1 ) );
		endif
		
		if( pagecount != len(circles) )
			layout.append( "button 294 4 2236 2236 0 " + ( pagecount + 1 ) );
		endif
		
		case( pagecount )
			1:	layout.append( "text 45  10 5 " + len(data) );
				data.append( "Lesser Ritual" );
				layout.append( "text 205 10 5 " + len(data) );
				data.append( "Adept Ritual" );
				break;
			
			2:	layout.append( "text 45  10 5 " + len(data) );
				data.append( "Greater Ritual" );
				layout.append( "text 205 10 5 " + len(data) );
				data.append( "Master Ritual" );
				break;		
		endcase

		while( i <= perCircle )
			if( FlagCheck( leftflag , i ) == 1 )
				lefttotal := lefttotal + 1;
				BookArray.append( leftarray[i] );
				layout.append( LeftButtonLayout[lefttotal] + len(BookArray) );
				layout.append( LeftTextLayout[lefttotal] + len(data) );
				data.append( leftdata[i] );
			endif
			
			if( FlagCheck( rightflag , i ) == 1 )
				righttotal := righttotal + 1;
				BookArray.append( rightarray[i] );
				layout.append( RightButtonLayout[righttotal] + len(BookArray) );
				layout.append( RightTextLayout[righttotal] + len(data) );
				data.append( rightdata[i] );
			endif
			
			i := i + 1;
		endwhile
	
	endforeach

	SendSysMessage( character , "Select the spell you want to scribe.");
	var res := SendDialogGump( character , layout , data );			 
	if( !res[0] )
		return 0;
	endif

	return BookArray[ res[0] ];

endfunction


function CopyBook( character , item )

	SendSysMessage( character , "Select an empty " + TruncateArticle(item.desc) + " to copy to." );
	var book := Target( character );
	if( !book )
		return;
	endif
	
	if( !Accessible( character , book ) )
		SendSysMessage( character , "You can't reach that" );
		return;
	endif
	
	if( !ReserveItem( book ) )
		return;
	endif
	
	if( item.objtype != book.objtype )
		SendSysMessage( character , "You must target a " + TruncateArticle(item.desc) + "." );
		return;
	endif
	
	if( item.objtype == UOBJ_SPELLBOOK )
		CopyNormalSpellbook( character , item , book );
		
	elseif( item.objtype == UOBJ_TOME_OF_ENCHANTMENT )
		CopyEnchantmentSpellbook( character , item , book );
		
	else
		CopyPaganSpellbook( character , item , book );
	endif

endfunction


function CopyEnchantmentSpellbook( character , item , book )

	if( GetObjProperty( book , "Circle1" ) or
	    GetObjProperty( book , "Circle2" ) or
	    GetObjProperty( book , "Circle3" ) or
	    GetObjProperty( book , "Circle4" ) )
	    	SendSysMessage( character , "You must target an empty tome of enchantment." );
		return;
	endif
	
	var mage	:= GetObjProperty( character , CLASSEID_MAGE );
	var skill	:= 170;
	var points	:= skill * POINT_MULTIPLIER;
	var manacost	:= 500;
	
	sendDiff( character , skill );

	if( mage )
		manacost := Cint( manacost / ClasseBonus( character, CLASSEID_MAGE ) );
	endif
	
	if( GetMana(character) < manacost )
		SendSysMessage( character , "You don't have enough mana." );
		return;
	else
		SetMana(character, GetMana(character) - manacost );
	endif
	
	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail to copy the tome." );
		DestroyItem( book );
		return;
	endif
	
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION ); 
	DupeItem( item , book );
	SendSysmessage( character , "You copied the Tome of Enchantments successfully." );
	
endfunction


function CopyNormalSpellbook( character , item , book )

	if( len(book.Spells()) > 0 )
		SendSysMessage( character , "You must target an empty book." );
		return;
	endif
	
	var mage	:= GetObjProperty( character , CLASSEID_MAGE );
	var skill	:= 110;
	var points	:= skill * POINT_MULTIPLIER;
	var manacost	:= 110;
	
	sendDiff( character , skill );

	if( mage )
		manacost := Cint( manacost / ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	if( GetMana(character) < manacost )
		SendSysMessage( character , "You don't have enough mana." );
		return;
	else
		SetMana(character, GetMana(character)-manacost);
	endif
	
	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail to copy the spellbook." );
		DestroyItem( book );
		return;
	endif
	
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION ); 
	SendSysmessage( character , "You copied the spellbook successfully." );

	foreach scroll in (item.Spells())
		book.AddSpell(scroll);
	endforeach

endfunction


function CopyPaganSpellbook( character , item , book )

	if( GetObjProperty( book , "Lesser" ) or
	    GetObjProperty( book , "Greater" ) )
	    	SendSysMessage( character , "You must target an empty book." );
		return;
	endif
	
	var mage := GetObjProperty( character , CLASSEID_MAGE );
	var skill;
	var manacost;
	
	if( item.objtype == UOBJ_CODEX_DAMNORUM )
		skill := 160;
		manacost := 160;
	else
		skill := 150;
		manacost := 150;
	endif
	
	var points := skill * POINT_MULTIPLIER;
	
	sendDiff( character , skill );

	if( mage )
		manacost := Cint( manacost / ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	if( GetMana(character) < manacost )
		SendSysMessage( character , "You don't have enough mana." );
		return;
	else
		SetMana(character, GetMana(character) - manacost);
	endif
	
	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail to copy the tome." );
		DestroyItem( book );
		return;
	endif
	
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION ); 
	DupeItem( item , book );
	SendSysmessage( character , "You copied the " + TruncateArticle(item.desc) + " successfully." );
	
endfunction


function CreateEarthSpellScroll( character , blankscroll , earthbook )

	var selected := ChooseEarthSpell( character , earthbook );
	if( !selected )
		return;
	endif
	
	var elem 	:= FindConfigElem( config_file , selected );
	var skill 	:= CInt( elem.FromBookDiff );
	var circle	:= CInt( elem.Circle );
	var points 	:= skill * POINT_MULTIPLIER;
	
	sendDiff( character , skill );

	CreateScroll( character , skill , points , blankscroll , selected , circle );
	
endfunction


function CreateNecroSpellScroll( character , blankscroll , codex )

	var selected := ChooseNecroSpell( character , codex );
	if( !selected )
		return;
	endif
	
	var elem 	:= FindConfigElem( config_file , selected );
	var skill 	:= CInt( elem.FromBookDiff );
	var circle	:= CInt( elem.Circle );
	var points 	:= skill * POINT_MULTIPLIER;
	
	sendDiff( character , skill );
	
	CreateScroll( character , skill , points , blankscroll , selected , circle );
	
endfunction

function CreateHolySpellScroll( character , blankscroll , holybook )

	var selected := ChooseHolySpell( character , holybook );
	if( !selected )
		return;
	endif
	
	var elem 	:= FindConfigElem( config_file , selected );
	var skill 	:= CInt( elem.FromBookDiff );
	var circle	:= CInt( elem.Circle );
	var points 	:= skill * POINT_MULTIPLIER;
	
	sendDiff( character , skill );
	
	CreateScroll( character , skill , points , blankscroll , selected , circle );
	
endfunction

function CreateNormalSpellScroll( character , blankscroll , spellbook )

	var selected := MakeAndProcessMenu( character , spellbook );
	if( !selected )
		return;
	endif
	var elem;
	var name_file := ReadConfigFile( "scribe" );
	foreach spell in ( spellbook.Spells() )
		var spellid := FindConfigElem(name_file, spell);
		var type:= GetConfigString(spellid, "scroll");
		if(type == selected)
			elem := FindConfigElem(name_file, spell);
		endif

	endforeach

	var skill 	:= CInt( elem.FromBookDiff );
	var circle	:= CInt( elem.Circle );
	var points 	:= skill * POINT_MULTIPLIER;
	var product	:= CInt( elem.Scroll );
	
	sendDiff( character , skill );
	
	CreateScroll( character , skill , points , blankscroll , product , circle );

endfunction


function CreateRitualSpellScroll( character , blankscroll , tome )

	var selected := ChooseRitualSpell( character , tome );
	if( !selected )
		return;
	endif
	
	var elem 	:= FindConfigElem( config_file , selected );
	var skill 	:= CInt( elem.FromBookDiff );
	var circle	:= CInt( elem.Circle );
	var points 	:= skill * POINT_MULTIPLIER;
	
	sendDiff( character , skill );
	
	CreateScroll( character , skill , points , blankscroll , selected , circle );

endfunction


function CreateRunebook( character , item )
	
	var needed	    := { UOBJ_GATE_SCROLL, UOBJ_RECALL_SCROLL, UOBJ_BLANK_SCROLL };
	var elem	    := FindConfigElem( config_file, UOBJ_RUNEBOOK );
	var needed_blank  := Cint( elem.BlankScrolls );
	var idifficulty   := Cint( elem.Inscription );
	var mdifficulty   := Cint( elem.Magery );
	var manacost	    := Cint( elem.Manacost );
	var points	    := idifficulty * POINT_MULTIPLIER;
	var mage	    := GetObjProperty( character, CLASSEID_MAGE );
	var the_component := { item };
	
	if( mage )
		manacost     := Cint( manacost / ClasseBonus( character , CLASSEID_MAGE ) );
		needed_blank := Cint( needed_blank / ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	foreach thing in needed
		var found := FindRootItemInContainer( character.backpack , thing );
		if( !found )
			SendSysMessage( character , "You don't have all needed components." );
			return;
		elseif( thing.objtype == UOBJ_BLANK_SCROLL and found.amount < needed_blank )
			SendSysMessage( character , "You don't have enough blank scrolls." );
			return;
		elseif( !ReserveItem( found ) )
			return;
		endif
		the_component.append( found );
	endforeach
	
	foreach object in the_component
		var amount := 1;
		if( object.objtype == UOBJ_BLANK_SCROLL )
			amount := needed_blank;
		endif
		SubtractAmount( object , amount );
	endforeach
	
	if( GetMana(character) < manacost )
		SendSysMessage( character , "You don't have enough mana." );
		return;
	else
		SetMana(character, GetMana(character)- manacost);
	endif
	
	if(!GetObjProperty(character, "toggleDiff"))
		SendSysmessage( character , "Inscription Difficulty: "+idifficulty );
		SendSysmessage( character , "Magery Difficulty: "+mdifficulty );
	endif

	if( !CheckSkill( character , SKILLID_INSCRIPTION , idifficulty , points ) )
		SendSysmessage( character , "You fail to create the runebook." );
		return;
	endif
	
	var magery_points := Cint( mdifficulty * POINT_MULTIPLIER );
	if( !CheckSkill( character , SKILLID_MAGERY , mdifficulty , magery_points ) )
		SendSysmessage( character , "You fail to create the runebook." );
		return;
	endif
		
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION );
	var runebook   := CreateItemInBackpack( character , UOBJ_RUNEBOOK );
	if( !runebook )
		SendSysMessage( character , "Your backpack is full!" );
		return;
	endif
	
	var maxcharges := 5 + Random(4);
	var excep_ch	 := 10;
	var excep_diff := idifficulty;
	if( mage )
		excep_ch := Cint( excep_ch * ClasseBonus( character , CLASSEID_MAGE ) );
	else
		excep_diff := excep_diff + 20;
	endif
				
	if( excep_diff < 90 )
		excep_diff := 90;
	endif

	if( (Random(100) < excep_ch) and CheckSkill( character , SKILLID_INSCRIPTION , excep_diff , 0 ) )
		SetObjProperty( runebook , "IsExceptional" , 1 );
		if(GetObjProperty(character, "ToggleBuildMark"))
			if( YesNo( character , "Add Builder Mark?" ))
				SetObjProperty( runebook , "CraftedBy" , character.name );
			endif
		else
			SetObjProperty( runebook , "CraftedBy" , character.name );
		endif
	
		SendSysmessage( character , "You create an exceptional runebook and put it in your backpack." );
		maxcharges	  := maxcharges + 2;
		runebook.buyprice := 25000;
	else
		SendSysmessage( character , "You create the runebook and put it in your backpack." );
	endif
	
	if( mage )
		maxcharges := Cint( maxcharges * ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	SetObjProperty( runebook , "maxcharges" , maxcharges );

endfunction


function CreateScroll( character , skill , points , blankscroll , scrollobjtype , circle )

	var conf 	 := ReadConfigFile(":*:circles");
	var manacost	 := conf[circle].Mana;
	var difficulty := conf[circle].Difficulty;
	var magery	 := GetEffectiveSkill( character , SKILLID_MAGERY );
	if( difficulty > 160 )
		difficulty := 160;
	endif

	if( manacost > 500 )
		manacost := 500;
	endif
	
	if( GetObjProperty( character , CLASSEID_MAGE ) )
		manacost   := Cint( manacost / ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	if( magery < difficulty - 20 )
		SendSysMessage( character , "You aren't skilled enough in the way of magic to make this scroll." );
		return;
	endif
	
      /*** Autolooping now starts ***/	
      Autoloop_init (character);

      while (Autoloop_more ()) 		

	/*** First check if there are at least one scroll. Maybe previous iterations had burned out all the scrolls ***/
	if( GetAmount ( blankscroll ) == 0 )
		SendSysMessage( character , "You don't have any more blank scrolls." );
		Autoloop_finish (); 
		return;
	endif	
	
	/*** Second check if there's enough mana left ***/
	if( GetMana(character) < manacost )
		SendSysMessage( character , "You don't have enough mana." );
		Autoloop_finish ();
		return;
	else
		SetMana(character, GetMana(character) - manacost );
	endif
	
	/*** If inscription failed, autolooping can continue ***/
	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail and destroy the scroll" );
		SubtractAmount( blankscroll , 1 );		
	else
	/*** That's ok ***/		
		CreateItemInBackpack( character , scrollobjtype );
		PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION ); 
		SendSysmessage( character , "You create the scroll and put it in your backpack" );
		SubtractAmount( blankscroll , 1 );
	endif

   endwhile
	
   Autoloop_finish();

endfunction


function EnchantItem( character , item )

	SendSysmessage( character , "Select a focus" );
	var focus := Target( character , TGTOPT_CHECK_LOS );
	if( !focus )
		return;
	endif
	
	var elem 	:= config_file[focus.objtype];
	var script	:= elem.Script;
	if( !script )
		SendSysmessage(character, "You must target an alchemical symbol.");
		return;
	endif
	
	if( !Accessible( character , focus ) )
		SendSysmessage( character , "You can't reach that!" );
		return;
	endif
	
	if( !ReserveItem( focus ) )
		return;
	endif

	var skill 	:= elem.Skill;
	var points 	:= skill * POINT_MULTIPLIER;
	var t_name 	:= elem.Name;
	var cost	:= elem.ChargeCost;
	var gemtype	:= elem.ChargeWith;
	var gemname	:= elem.GemName;
	
	if( GetObjProperty( character , CLASSEID_MAGE ) )
		cost := Cint( cost / ClasseBonus( character , CLASSEID_MAGE ) );
	endif
	
	SendSysmessage( character , "Select " + cost + " " + gemname + " for each charge you wish to place on the item." );
	SendSysmessage( character , "Beware, the higher the number of charges, the higher is the risk of failure!" );
	SendSysmessage( character , "You must put at least one charge during the initial enchantment." );
		
	var gem 	:= Target( character , TGTOPT_CHECK_LOS );
	var diff 	:= cost;
	var charges 	:= 0;
		
	while( gem )
		
		if ( !Accessible( character , gem ) )
			SendSysmessage( character , "You can't reach that!" );
			gem := Target( character , TGTOPT_CHECK_LOS );
			continue;
		endif
			
		if( gem.objtype == gemtype )
			var amount := Cint( gem.amount / cost );
			if( amount )
				SubtractAmount( gem , cost );
				if( CheckSkill( character , SKILLID_MAGERY , diff , 0 ) )
					charges := charges + 1;
					SendSysmessage( character , "There's now " + charges + " charges stored." );
					diff := diff + (charges * cost);
				else
					SendSysmessage( character , "The magical energy go out of control!" );
					DestroyItem( item );
					DestroyItem( focus );
					ApplyRawDamage( character , Cint(charges * cost * 1.5) );
					return;
				endif
			else
				SendSysmessage( character , "There isn't enough gems in that stack, you need " + cost + " gems per charges you want to put in." );
			endif
		else
			SendSysmessage( character , "That's not a gem, or not a " + gemname + "." );
		endif
			
		SendSysmessage( character, "Hit Esc if you have enough charges." );
		gem := Target( character , TGTOPT_CHECK_LOS );
			
	endwhile
		
		
	if( !charges )
		SendSysmessage ( character , "You didn't set any charges!" );
		
	elseif( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points + (charges * cost * POINT_MULTIPLIER) ) )
		//failure
		SendSysmessage ( character , "You fail, and destroy the item." );
		DestroyItem( item );
		
	elseif( !CheckSkill( character , SKILLID_MAGERY , skill , (charges * cost * POINT_MULTIPLIER) ) )
		//failure
		SendSysmessage ( character , "You fail, and destroy the item." );
		DestroyItem( item );

	else

	    	item.usescript := script;
	    	var cprops := GetConfigStringArray( elem , "CProp" );
	    	foreach cprop in cprops
	    		var prop_data := SplitWords( cprop );
	    		SetObjProperty( item , prop_data[1] , prop_data[2] );
	    	endforeach
	    	
		SetObjProperty( item , "charges", charges );
		PlayObjectCenteredEffect( character , EFFECT_SPARKLE , 7 , 0x10 );
		PlaySoundEffect( character , SOUND_EFFECT_SPARKLE );
		ChangeName( item , t_name );
		SetObjProperty( item , "EnchantedWith" , focus.objtype );
	endif
	
	DestroyItem( focus );
	
endfunction


function InscribeEarthSpell(character, item)
	
	SendSysmessage( character, "Select your Earth Book in which to inscribe." );
	
	var book := Target( character , TGTOPT_CHECK_LOS );
	if (!book)
		return;
	endif 
	
	if ( !Accessible(character, book) )
		SendSysmessage (character, "You can't reach that!");
		return;
	endif
	
	if( book.objtype != 0xB100 )
		SendSysmessage (character, "You must select a Book of the Earth!");
		return;
	endif

	var elem	:= FindConfigElem( config_file , item.objtype );
	var skill	:= Cint( elem.ToBookDiff );
	var points	:= skill * (POINT_MULTIPLIER + 5);
	var flagRegister := elem.flagset;
	var flag	:= elem.flag;
	var circle	:= "";

	if( FlagRegister == 1 )
		circle := "Lesser";
	else
		circle := "Greater";
	endif

	flagRegister := GetObjProperty( book , circle );
	flagRegister := Cint(flagRegister);

	if( FlagCheck( flagRegister , flag ) == 1 )
		SendSysMessage(character, "That spell is already inscribed.");
		return;
	endif

	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail, and destroy the scroll" );
		SubtractAmount( item , 1 );
		return;	  
	endif
	
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION );
	PlayObjectCenteredEffect( book , EFFECT_SPARKLE , 10 ,10 );
	SubtractAmount( item , 1 );
	SendSysmessage (character, "You inscribe the spell into your Earth Book.");
	flagRegister := FlagSet( flagRegister , flag );
	flagRegister := CStr( flagRegister );
	SetObjProperty( book , circle , flagRegister );
	
endfunction

function InscribeHolySpell(character, item)
	
	SendSysmessage( character, "Select your Holy Book in which to inscribe." );
	
	var book := Target( character , TGTOPT_CHECK_LOS );
	if (!book)
		return;
	endif 
	
	if ( !Accessible(character, book) )
		SendSysmessage (character, "You can't reach that!");
		return;
	endif
	
	if( book.objtype != 0x6166 )
		SendSysmessage (character, "You must select a Holy Book!");
		return;
	endif

	var elem	:= FindConfigElem( config_file , item.objtype );
	var skill	:= Cint( elem.ToBookDiff );
	var points	:= skill * (POINT_MULTIPLIER + 5);
	var flagRegister := elem.flagset;
	var flag	:= elem.flag;
	var circle	:= "";

	if( FlagRegister == 1 )
		circle := "Lesser";
	else
		circle := "Greater";
	endif

	flagRegister := GetObjProperty( book , circle );
	flagRegister := Cint(flagRegister);

	if( FlagCheck( flagRegister , flag ) == 1 )
		SendSysMessage(character, "That spell is already inscribed.");
		return;
	endif

	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail, and destroy the scroll" );
		SubtractAmount( item , 1 );
		return;	  
	endif
	
	PlaySoundEffect( character , SOUND_EFFECT_INSCRIPTION );
	PlayObjectCenteredEffect( book , EFFECT_SPARKLE , 10 ,10 );
	SubtractAmount( item , 1 );
	SendSysmessage (character, "You inscribe the spell into your Holy Book.");
	flagRegister := FlagSet( flagRegister , flag );
	flagRegister := CStr( flagRegister );
	SetObjProperty( book , circle , flagRegister );
	
endfunction

function InscribeNecroSpell(character, item)
	
	SendSysmessage( character , "Select the infernal tome in which to inscribe." );
	
	var book := Target( character , TGTOPT_CHECK_LOS );
	if( !book )
		return;
	endif 
	
	if( !Accessible(character, book) )
		SendSysmessage( character , "You can't reach that!" );
		return;
	endif
	
	if( book.objtype != 0xA100 )
		SendSysmessage (character, "You must select a necromatic spellbook.");
		return;
	endif

	var elem	:= FindConfigElem(config_file, item.objtype);
	var skill	:= Cint( elem.ToBookDiff );
	var points	:= skill * (POINT_MULTIPLIER + 5);
	var flagRegister := elem.flagset;
	var flag	:= elem.flag;
	var circle	:= "";

	if( flagRegister == 1 )
		circle := "Lesser";
	else
		circle := "Greater";
	endif

	flagRegister := GetObjProperty( book , circle );
	flagRegister := Cint( flagRegister );

	if( FlagCheck(flagRegister, flag) == 1 )
		SendSysMessage( character , "That spell is already inscribed." );
		return;
	endif

	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail, and destroy the scroll" );
		SubtractAmount( item , 1 );
		return;
	endif
	
	PlaySoundEffect(character, SOUND_EFFECT_INSCRIPTION); 
	PlayObjectCenteredEffect( book, EFFECT_SPARKLE, 10,10);
	SubtractAmount(item,1);
	SendSysmessage (character, "You inscribe the spell into your Codex.");
	flagRegister := FlagSet( flagRegister , flag );
	flagRegister := CStr( flagRegister );
	SetObjProperty( book , circle , flagRegister );

endfunction


function InscribeRitualSpell( character , scroll )

	SendSysmessage( character , "Select the tome of enchantment in which to inscribe." );
	
	var book := Target( character , TGTOPT_CHECK_LOS );
	if( !book )
		return;
	endif 
	
	if( !Accessible( character , book ) )
		SendSysmessage( character , "You can't reach that!" );
		return;
	endif
	
	if( book.objtype != 0xC100 )
		SendSysmessage (character, "You must select a tome of enchantment.");
		return;
	endif

	var elem	:= FindConfigElem( config_file , scroll.objtype );
	var skill	:= Cint( elem.ToBookDiff );
	var points	:= skill * (POINT_MULTIPLIER + 5);
	var flagRegister := elem.flagset;
	var flag	:= elem.flag;
	var circle	:= "Circle" + flagRegister;


	flagRegister := GetObjProperty( book , circle );
	flagRegister := Cint( flagRegister );

	if( FlagCheck( flagRegister , flag ) == 1 )
		SendSysMessage( character , "That spell is already inscribed." );
		return;
	endif

	if( !CheckSkill( character , SKILLID_INSCRIPTION , skill , points ) )
		SendSysmessage( character , "You fail, and destroy the scroll" );
		SubtractAmount( scroll , 1 );
		return;
	endif
	
	PlaySoundEffect(character, SOUND_EFFECT_INSCRIPTION); 
	PlayObjectCenteredEffect( book, EFFECT_SPARKLE, 10,10);
	SubtractAmount( scroll , 1 );
	SendSysmessage (character, "You inscribe the spell into your tome of enchantment.");
	flagRegister := FlagSet( flagRegister , flag );
	flagRegister := CStr( flagRegister );
	SetObjProperty( book , circle , flagRegister );

endfunction


function IsExceptionalItem( item )

	if( !GetObjProperty( item , "IsExceptional" ) )
		return 0;
	elseif( item.isa( POLCLASS_CONTAINER ) )
		return 0;
	else
		return 1;
	endif
	
endfunction

// only used for normal scrolls
function MakeAndProcessMenu( character , spellbook )

	////set_priority(1);   
	var circles := { };
	

	var name_file := ReadConfigFile( "scribe" );
	foreach spell in ( spellbook.Spells() )
		var spellid := FindConfigElem(name_file, spell);
		var thecircle := GetConfigInt(spellid, "Circle");
		circles[thecircle] := 1;
	endforeach

	var i;
	var tmenu := CreateMenu("Select a circle to inscribe");

	for (i := 1; i <= 8; i := i + 1)
		if (circles[i] == 1)
			AddMenuItem(tmenu, 0x20bf + i, "Circle " + cstr(i) + " spells");
		endif
	endfor


	var firstchoice:= SelectMenuItem2(character, tmenu);

	if (!firstchoice.index)
		
		return 0;
	endif

	var tmenu2 := CreateMenu("Select a spell to inscribe");
	var scrolls_objtype := {};
	foreach spell in  ( spellbook.Spells() )
		var elem := FindConfigElem(name_file, spell);
		var thecircle := GetConfigInt(elem, "Circle");
		if (thecircle == firstchoice.objtype - 0x20bf)
			var spellname := GetConfigString(elem, "Name");
			var thetype := GetConfigString(elem, "graphic");
			var type:= GetConfigString(elem, "scroll");
			scrolls_objtype.append(	(type) );
			AddMenuItem(tmenu2, thetype, spellname);
		endif
	endforeach
	

	var hischoice := SelectMenuItem2(character, tmenu2);

   
	////set_priority(50);
	if( !hischoice.index )
		return 0;
	else
		return scrolls_objtype[hischoice.index];
	endif
	
endfunction


function RechargeItem( character , item )

	var gemtype	:= Hex( GetObjProperty( item , "Rechargeable" ) );
	var elem 	:= config_file[gemtype];
	var gemname	:= elem.GemName;
	var charges	:= Cint( GetObjProperty( item , "charges" ) );
	var maxx	:= Cint( GetObjProperty( item , "maxcharges" ) );
	var cost	:= GetObjProperty( item , "CostPerCharge" );
	if( !cost )
		cost := 1;
	endif
	
	if( !elem )
		SendSysMessage( character , "Invalid gem type..." );
		return;
	endif
	
	SendSysmessage( character , "Select " + cost + " " + gemname + " for each charge you wish to recharge on the item." );

	var gem 	:= Target( character , TGTOPT_CHECK_LOS );
	var initial_charges := charges;

	while( gem )
		
		if( !Accessible( character , gem ) )
			SendSysmessage( character , "You can't reach that!" );
			gem := Target( character , TGTOPT_CHECK_LOS );
			continue;
		endif
			
		if( gem.objtype == gemtype )
			var amount := Cint( gem.amount / cost );
			if( amount )
				SubtractAmount( gem , cost );
				if( CheckSkill( character , SKILLID_MAGERY , 100 , 500 ) )
					charges := charges + 1;
					if( charges < maxx )
						SendSysmessage( character , "There's now " + charges + " charges stored." );
					else
						SendSysmessage( character , "This item is at his max amount of charges." );
						if( charges > maxx )
							charges := maxx;
						endif
						break;
					endif

				else
					SendSysmessage( character , "The magical energy go out of your control!" );
					DestroyItem( item );
					ApplyRawDamage( character , charges * cost );
					return;
				endif
			else
				SendSysmessage( character , "There isn't enough gems in that stack, you need " + cost + " gems per charges you want to put in." );
			endif
		else
			SendSysmessage( character , "That's not a gem, or not a " + gemname + "." );
		endif
			
		SendSysmessage( character, "Hit Esc if you have enough charges." );
		gem := Target( character , TGTOPT_CHECK_LOS );	
	endwhile
	
	if( charges != initial_charges )
		SetObjProperty( item , "charges" , charges );
		SendSysMessage( character , "The item was successfully recharged to " + charges + " charges." );
	endif

endfunction


function RechargeEngravedItem( character , item , focus_type )

	var elem 	:= config_file[focus_type];
	if ( !elem )
		return;
	endif
	
	var skill 	:= elem.Skill;
	var points 	:= Cint( skill * POINT_MULTIPLIER / 3 );
	var cost	:= elem.ChargeCost;
	var gemtype	:= elem.ChargeWith;
	var gemname	:= elem.GemName;
	
	if( GetObjProperty( character , CLASSEID_MAGE ) )
		cost := Cint( cost / ClasseBonus( character , CLASSEID_MAGE ) );
	endif

	SendSysmessage( character , "Select " + cost + " " + gemname + " for each charge you wish to recharge on the item." );

	var gem 	:= Target( character , TGTOPT_CHECK_LOS );
	var charges	:= GetObjProperty( item , "charges" );
	var initial_charges := charges;
	if( !charges )
		charges := 0;
	endif
		
	while( gem )
		
		if( !Accessible( character , gem ) )
			SendSysmessage( character , "You can't reach that!" );
			gem := Target( character , TGTOPT_CHECK_LOS );
			continue;
		endif
			
		if( gem.objtype == gemtype )
			var amount := Cint( gem.amount / cost );
			if( amount )
				SubtractAmount( gem , cost );
				if( CheckSkill( character , SKILLID_MAGERY , skill , points ) )
					charges := charges + 1;
					SendSysmessage( character , "There's now " + charges + " charges stored." );

				else
					SendSysmessage( character , "The magical energy go out of your control!" );
					DestroyItem( item );
					ApplyDamage( character , charges * cost );
					return;
				endif
			else
				SendSysmessage( character , "There isn't enough gems in that stack, you need " + cost + " gems per charges you want to put in." );
			endif
		else
			SendSysmessage( character , "That's not a gem, or not a " + gemname + "." );
		endif
			
		SendSysmessage( character, "Hit Esc if you have enough charges." );
		gem := Target( character , TGTOPT_CHECK_LOS );	
	endwhile
	
	if( charges != initial_charges )
		SetObjProperty( item , "charges" , charges );
		SendSysMessage( character , "The item was successfully recharged to " + charges + " charges." );
	endif
	
endfunction



function WantToCreateScroll( character , blankscroll )

	SendSysmessage( character, "Select a spellbook from which to inscribe." );
	
	var book := Target( character , TGTOPT_CHECK_LOS );
	if ( !book )
		return;
	endif 

	if ( !Accessible( character , book ) )
		SendSysmessage (character, "You can't reach that!");
		return;
	endif

	if ( !ReserveItem (book) )
		return;
	endif

	if( book.objtype != UOBJ_SPELLBOOK and book.objtype != 0xA100 and book.objtype != 0xB100 and book.objtype != 0xC100 and book.objtype != 0x6166 )
		SendSysmessage (character, "You must select a spellbook!");
		return;
	endif

	if( book.objtype == UOBJ_SPELLBOOK )
		CreateNormalSpellScroll( character , blankscroll , book );
		
	elseif( book.objtype == 0xA100 )
		CreateNecroSpellScroll( character , blankscroll , book );
	
	elseif( book.objtype == 0xB100 )
		CreateEarthSpellScroll( character , blankscroll , book );
	elseif( book.objtype == 0x6166 )
		CreateHolySpellScroll( character , blankscroll , book );
	elseif( book.objtype == 0xC100 )
		CreateRitualSpellScroll( character , blankscroll , book );
	endif

endfunction

function CheckIfEmpty( character , item )

	if( EnumerateItemsInContainer(item).size() < 1) 
		SendSysmessage (character, "You cannot copy an empty spellbook.");
		return;
	else
		CopyBook( character , item );
	endif
endfunction

function CheckIfEmptyNormal( character , item )
		
	if( len(item.Spells()) < 1) 
		SendSysmessage (character, "You cannot copy an empty spellbook.");
		return;
	else
		CopyBook( character , item );
	endif
endfunction
